
import pandas as pd
import multiprocessing
from concurrent.futures import ThreadPoolExecutor
from optbinning import OptimalBinning

def process_variable(x_var, base):
    """
    Performs optimal binning with WoE transformation using `optbinning`.
    """
    y_var = 'TARGET'  # Binary target for delinquency

    try:
        # Initialize binning object (auto-optimizes bins)
        opt_bin = OptimalBinning(name=x_var, dtype="numerical", solver="cp", monotonic_trend="auto")

        # Fit binning model
        opt_bin.fit(base[x_var], base[y_var])

        # Get WoE-transformed values
        df_woe = pd.DataFrame({x_var: base[x_var]})
        df_woe['WoE_' + x_var] = opt_bin.transform(base[x_var], metric="woe")

        # Compute Information Value (IV)
        iv_value = opt_bin.information_value()
        print(f"âœ… IV for {x_var}: {iv_value:.4f}")

        return df_woe['WoE_' + x_var], x_var

    except Exception as e:
        print(f"Skipping {x_var} due to error: {e}")
        return None, None


woe_vars = []
non_woe_vars = []
num_cores = multiprocessing.cpu_count()

with ThreadPoolExecutor(max_workers=num_cores) as executor:
    futures = {executor.submit(process_variable, x_var, base): x_var for x_var in ret_vars}
    
    for future in futures:
        try:
            woe_series, x_var = future.result()
            if woe_series is not None:
                base['WoE_' + x_var] = woe_series
                woe_vars.append(x_var)
            else:
                non_woe_vars.append(x_var)
        except Exception as e:
            print(f"Thread error: {e}")
